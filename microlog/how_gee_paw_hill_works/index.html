<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.71.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=keywords content="programming,software development,golang,tdd,agile"><meta name=description content><meta property="og:title" content="How does GeePaw Hill work?"><meta property="og:description" content="Tweet thread: How I Work: (Just Programming Mix)
When I'm programming, I am centered broadly on the cyclical application of small textual changes, each one producing value I then harvest to identify, enable, or energize the next.
&mdash; GeePaw Hill (@GeePawHill) November 23, 2019  Unrolled thread:  When I&rsquo;m programming, I am centered broadly on the cyclical application of small textual changes, each one producing value I then harvest to identify, enable, or energize the next."><meta property="og:type" content="article"><meta property="og:url" content="https://dc0d.github.io/microlog/how_gee_paw_hill_works/"><meta property="article:published_time" content="2020-05-23T23:56:20+02:00"><meta property="article:modified_time" content="2020-05-23T23:56:20+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How does GeePaw Hill work?"><meta name=twitter:description content="Tweet thread: How I Work: (Just Programming Mix)
When I'm programming, I am centered broadly on the cyclical application of small textual changes, each one producing value I then harvest to identify, enable, or energize the next.
&mdash; GeePaw Hill (@GeePawHill) November 23, 2019  Unrolled thread:  When I&rsquo;m programming, I am centered broadly on the cyclical application of small textual changes, each one producing value I then harvest to identify, enable, or energize the next."><link rel=icon type=image/png href=/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicon-16x16.png sizes=16x16><link rel=stylesheet type=text/css media=screen href=https://dc0d.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://dc0d.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://dc0d.github.io/css/all.css><link rel=stylesheet href=https://dc0d.github.io/css/katex.min.css crossorigin=anonymous><script defer src=https://dc0d.github.io/js/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://dc0d.github.io/js/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body);></script><title>How does GeePaw Hill work? | sketches</title></head><body><header><div id=avatar><a href=https://dc0d.github.io/><img src=/images/logo.png alt=sketches></a></div><div id=titletext><h2 id=title><a href=https://dc0d.github.io/>sketches</a></h2></div><div id=title-description><p id=subtitle>sketches for software development</p><div id=social><nav><ul><li><a href=/index.xml><i title=RSS class="icons fas fa-rss"></i></a></li><li><a href=https://twitter.com/__dc0d__><i title=Twitter class="icons fab fa-twitter"></i></a></li><li><a href=mailto:kaveh@shahbazian.link><i title=Email class="icons fas fa-envelope"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/tags>Tags</a></li><li><a href=/about>About</a></li></ul></nav></div></header><main><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>23</span>
<span class=rest>May 2020</span></div></div><div class=matter><h1 class=title>How does GeePaw Hill work?</h1></div></div><div class=markdown><h3 id=tweet-thread>Tweet thread:</h3><blockquote class=twitter-tweet><p lang=en dir=ltr>How I Work: (Just Programming Mix)<br><br>When I'm programming, I am centered broadly on the cyclical application of small textual changes, each one producing value I then harvest to identify, enable, or energize the next.</p>&mdash; GeePaw Hill (@GeePawHill) <a href="https://twitter.com/GeePawHill/status/1198354786049019905?ref_src=twsrc%5Etfw">November 23, 2019</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><h3 id=unrolled-threadhttpsthreadreaderappcomthread1198354786049019905html>Unrolled <a href=https://threadreaderapp.com/thread/1198354786049019905.html>thread</a>:</h3><blockquote><p>When I&rsquo;m programming, I am centered broadly on the cyclical application of small textual changes, each one producing value I then harvest to identify, enable, or energize the next.</p><p>Before we dig in: This is how <em>I</em> roll code. It is not a prescription of any kind for you. I have a prescription for you, and I can offer it, but it has almost nothing to do with what you&rsquo;ll read here. These are details. The prescriptions are at a much higher level.</p><p>You do you.</p><p>A couple of words about environment. I roll code using an IDE almost exclusively. I use Intellij&rsquo;s family these days. I&rsquo;ve tons of experience w/Visual Studio & Eclipse. I&rsquo;ve used a number of others at different times, and gradually set them aside when I found ones I liked more.</p><p>I use an IDE because I like my tools to know as much and sometimes even more than I do about my language, my libraries, and my project. I&rsquo;ve found them quite useful to me in dynamically typed languages and invaluable to me in static ones.</p><p>Left to my own devices, I use git for my source vault. (Like any long-time geek, I&rsquo;ve used&rsquo;em all.) I use git <em>very</em> simply. I avoid cherry-picking changes. I avoid manual merges. I live branchlessly, pulling from head, pushing to head, testing at head.</p><p>90% of my git usage is contained in just three commands: pull -r, commit -m, and push. I use the root dir for all of that. When I <em>do</em> get stuck with a manual merge of any kind or size, I normally just emit obscenities, throw away my change, and do it again.</p><p>Meta 1: as a long time geek, I read maybe 25 or so programming languages. I can write 8, am fluent in five, and am expert in 3: Forth, C/C++, Java/Kotlin. (A little early to claim Kotlin &ldquo;expert&rdquo;, but the fallback to Java helps.) My dynamics are Python & Ruby.</p><p>Meta 2: I have written every kind of software professionally with one exception, that of professional video game development. I&rsquo;ve written hard realtime, database-to-web, desktop apps, analytics, process control, device drivers, UI&rsquo;s, spreadsheets, word processors.</p><p>Meta 3: Collaboration is central to professional software development, but I&rsquo;m going to elide most of that in this mix. In a full team, I like to solo, pair, and mob, roughly 1/3 time each. All three are skills, and I have studied them and practiced at them to get better.</p><p>To cases, then. The first thing I do when I roll code is reassure myself by whatever means that I meet two criteria: 1) I have a problem I &ndash; more or less &ndash; understand. 2) I have a problem I &ndash; more or less &ndash; can solve in one and a half &ldquo;good days&rdquo;.</p><p>How I do that is neither here nor there for this mix. The point is that I do. I&rsquo;ll push both those limits sometimes, though not usually at the same time. Two and a half &ldquo;good days&rdquo; I might live with, or I am pretty sure the problem is &ldquo;somewhere in that pile over there&rdquo;.</p><p>So once I have the problem, the code rolling begins, yeah?</p><p>Unless I&rsquo;m working on a problem I&rsquo;m already quite intimate with, I start rolling code by, ummmm, furiously not typing any code into the computer.</p><p>You ever watch a king-hell drummer set up a full kit for a serious concert? She&rsquo;ll get things into a rough approximation of her standard arrangement. Then she tinkers. Raise that a half-inch. Move that just a little further to the right. She&rsquo;ll hit a thing twice.</p><p>As she proceeds &ndash; it might take an hour &ndash; she&rsquo;ll play short phrases where she hits two things, or three. They get progressively closer to sounding like whole little chunks. (It&rsquo;s really quite cool to watch. I, for the life of me, can never quite tell what she&rsquo;s sensing.)</p><p>What she&rsquo;s doing is situating herself, centering herself in the elements of her problem and her range of tools for solving it.</p><p>I use &ldquo;situating&rdquo; on purpose. She is building what the army calls &ldquo;situational awareness.&rdquo;</p><p>Now, her problem and her tools for solving it are very different from mine. But I totally recognize the situating, because that&rsquo;s what I do, too. I even thump a few things sometimes, and make little adjustments to them.</p><p>As a pure code monkey, my greatest asset is unquestionably my ability to organize, to rapidly arrange and re-arrange ideas out there in mind-stuff, where the Platonic forms live. To do that, I have to know where things are now, what kind of things they are, their size & shape.</p><p>But situating myself isn&rsquo;t just remembering what&rsquo;s there. It&rsquo;s ultimately formulating some kind of change-plan. I do that by doing things that amount to a kind of labeling: &ldquo;blocker&rdquo;, &ldquo;detail&rdquo;, &ldquo;totally irrelevant&rdquo;, &ldquo;bingo&rdquo;, &ldquo;scary&rdquo;, &ldquo;hackable&rdquo;.</p><p>Now, &ldquo;change-plan&rdquo; sounds like I&rsquo;m making a list or something. And I might be, if the problem is hard or the existing design is bad or I&rsquo;m having a nervous day. But just as likely I&rsquo;m just banging around in the code, scanning things, following links, checking and double-checking.</p><p>I might draw a picture. I might rubber-duck it with my long-suffering wife or my infinitely patient dogs. I do some of the work pacing around outside smoking. Sometimes I mentally practice giving a presentation to a roomful of geeks.</p><p>Finally, I reach a place where my confidence and my nervousness are in some right tension, and I&rsquo;m ready to start making some damned changes.</p><p>The changes I make are small. In fact, I sort them that way by asking questions in a certain (rough and sometimes varying order).</p><p>What&rsquo;s the smallest change that 1) the language will think is legal, 2) is detectable by me, 3) is detectable by a test, 4) is detectable to a user, in that order.</p><p>But it isn&rsquo;t as simple as sorting on a single criterion. I also throw stuff in the mix like &ldquo;enabling&rdquo; &ndash; changes that enable other changes come sooner &ndash; &ldquo;sexy&rdquo; &ndash; changes that are really cool come later &ndash; &ldquo;no-brainer&rdquo; changes I have complete confidence in come sooner, & so on.</p><p>In a typical day-and-a-half problem, I might spend two hours just wandering around in the code doing all this. Of course, it&rsquo;s much faster if the code is expressive and tested.</p><p>Notice, btw, how much wild uncertainty there is involved in all this pondering and sorting and plan-making and goofing in the code. It&rsquo;s basically guesswork shaped by experience and taste and the gradual refinement of my situational awareness.</p><p>And then I change code. :)</p><p>In some problems, the bulk of the changes are actually enabling ones. That is, I&rsquo;m schmooshing the code around typographically w/o changing what it does to get it all lined up for a string of <em>real</em> changes.</p><p>The other word for schmoosing code around typographically like that is &ldquo;refactoring&rdquo;. Because I use an IDE, I use and prefer a lot of automated refactorings, because they&rsquo;re fast and (generally regarded as though not guaranteed in all circumstances to be) safe.</p><p>But I can&rsquo;t use automated refactorings for everything, so I mix and match manual and automatic. Depending on my confidence level in the size of the change, I may start these changes by writing some tests around &ldquo;what it does now&rdquo;. I may not.</p><p>When I get to a &ldquo;real&rdquo; change, I do it by first deciding whether or not it&rsquo;s testable. If it is, I write a test for it. If it&rsquo;s not &ndash; damnit &ndash; I have to decide whether I can make it testable with some enabling changes or whether it&rsquo;s simply not worth the cost.</p><p>Some folks &ldquo;always&rdquo; work outside-in, meaning that they start by changing things near the top of the dependency graph and work their way down until they&rsquo;re done.</p><p>I don&rsquo;t &ldquo;always&rdquo; do anything, and have and do work sometimes in both of those ways. But mostly, what I do is think my way from the top of the dependency tree down to that core change, then test & code the &ldquo;enable&rdquo; changes below it, then test & code my way back out.</p><p>I obsess over the size of the changes I make. A typical pull-change-push cycle, in a kotlin app, is something from 3 minutes to 15 in duration. I can go 25-30 if it feels &ldquo;good, just more time-consuming than I thought&rdquo;. I very rarely persist after 45 minutes. I toss & start over.</p><p>That thing, &ldquo;toss and start over&rdquo;, is <em>super</em> important and comes as a surprise to a lot of geeks, young and old, who seem to me a little too attached to what they have already typed.</p><p>Typing is easy. Knowing is hard. When I fail at a change after 45 minutes, I&rsquo;m failing at it because I didn&rsquo;t know what to type. Further, what I typed since I started that change was <em>ipso facto</em> not enough to close the change. It is just by-product to me, to be disposed.
(That&rsquo;s also why I don&rsquo;t normally do hand-merges. Good lord, it&rsquo;s just typing, and it took me as long as it took me largely because I didn&rsquo;t know what it was going to be. Now that I know, I can type it one helluva lot faster.)</p><p>So.</p><p>Let&rsquo;s wrap this. I can do more of these &ldquo;How I Work&rdquo; muses, focusing on aspects other than &ldquo;Just Programming&rdquo;.</p><p>The real point, I think, for me at least, of this one, is that my &ldquo;system&rdquo; for rolling code is one centered heavily around cycles of small changes, harvesting of partial value, and using a lot of judgment. There&rsquo;s no lurking algorithm in how I code.</p><p>Anyway, it&rsquo;s a wild and crazy Saturday night here. Virginia and I are going to watch a Midsomer Murder episode and eat fantastic carry-out I picked up earlier.</p><p>I hope you, too, have a wild and crazy Saturday night with good food, your sweetheart, doing something you enjoy!</p></blockquote></div><div class=tags></div></div></main><footer></footer></body></html>